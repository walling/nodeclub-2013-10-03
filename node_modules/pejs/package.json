{
  "name": "pejs",
  "version": "0.6.1",
  "keywords": [
    "template",
    "ejs",
    "inheritance",
    "render"
  ],
  "description": "Pre-compiled EJS with inheritance, block and file support that works both in the client and on the server",
  "repository": {
    "type": "git",
    "url": "git://github.com/gett/pejs"
  },
  "author": {
    "name": "Ge.tt",
    "email": "hello@ge.tt"
  },
  "bin": {
    "pejs": "./cli.js"
  },
  "dependencies": {
    "resolve": "~0.5.0"
  },
  "contributors": [
    {
      "name": "Mathias Buus Madsen",
      "email": "m@ge.tt"
    }
  ],
  "scripts": {
    "test": "node tests"
  },
  "readme": "# PEJS\n\nPEJS is pre-compiled EJS with a inheritance, blocks and file support that works both in the client and on the server.\nIt's available through npm:\n\n\tnpm install pejs\n\n## Usage\n\nPEJS is easy to use:\n\n``` js\nvar pejs = require('pejs');\n\npejs.render('./example.ejs', function(err, result) {\n\t// renders example.ejs into a string\n\tconsole.log(result);\n});\npejs.parse('./example.ejs', function(err, src) {\n\t// parses the template and compiles it down to portable js\n\t// this means it works in the client!\n\tconsole.log(src);\n});\n```\n\nPEJS has an internal cache of parsed templates which means that when you render a template\ntwice it will only parse it once.\n\nIt also makes sure to clear this cache if the template has changed in anyway on the disk\n\n## Path resolution\n\nPEJS uses a similar file/module resolution as node.js.\n\n* `pejs.render('./file')`: pejs will look for `file.ejs`, `file.html`, `file/index.ejs` or `file/index.html`.\n* `pejs.render('template')`: pejs will look for for `template` in in the nearest `views` folder using the same scheme as above.\n\nThis is almost exactly the same as node does with it's `node_modules` resolution.\n\n## Classic EJS\n\nPEJS templates has your usual EJS syntax with `<%` and `%>`. Read more about EJS [here](http://embeddedjs.com/)\n\n* inline code: `<% var a = 42; %>`\n* insert: `<%- data %>`\n* escape: `<%= data %>`\n\n## Blocks\n\nPEJS expands the original EJS syntax by letting you declare blocks using the `<%{` syntax.\nA block is basically a partial template that optionally can be loaded from a file.\n\n* declare block: `<%{{ blockName }}%>`\n* declare file block: `<%{ './filename.html' }%>`\n* override block: `<%{ blockName %>hello block<%} %>`\n\nIn general all block can be loaded from a file instead of being defined inline by providing a filename:\n\n* declare block: `<%{{ myBlock './example.ejs' }}%>`\n* override block: `<%{ myOverrideBlock 'example.ejs' }%>`\n\nIf you want include a block using a different set of locals than in you current scope you pass these as the last argument to the block.\n\n* declare block: `<%{{ myBlock {newLocalsArg:oldLocalsArg} }}%>`\n* override block: `<%{ './example.ejs', newLocalsHere }%>`\n\nAll filepaths above are subject to the same path resolution as decribed in the previous section.\n\n## Inheritance\n\nUsing blocks it's easy to implement template inheritance.\nJust declare a `base.html` with some anchored blocks:\n\n\t<body>\n\t\tHello i am base\n\t\t<%{{ content }}%>\n\t</body>\n\nThen a `child.html` that renders `base.html`\n\n\t<%{ './base.html' }%>\n\t<%{ content %>\n\t\ti am inserted in base\n\t<%} %>\n\nTo render the example just render `child.html`\n\n``` js\npejs.render('./child.html', function(err, result) {\n\tconsole.log(result);\n});\n```\n\nThe above outputs:\n\n\t<body>\n\t\tHello i am base\n\t\ti am inserted in base\n\t</body>\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/gett/pejs/issues"
  },
  "_id": "pejs@0.6.1",
  "_from": "pejs@"
}
